var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// utils/buildUrl.js
var require_buildUrl = __commonJS({
  "utils/buildUrl.js"(exports2, module2) {
    module2.exports = function buildUrl2(url, dameInstance) {
      if (!url)
        return "";
      if (url.startsWith("http://") || url.startsWith("https://"))
        return url;
      if (dameInstance.baseUrl)
        return dameInstance.baseUrl + url;
      return url;
    };
  }
});

// utils/buildHeaders.js
var require_buildHeaders = __commonJS({
  "utils/buildHeaders.js"(exports2, module2) {
    module2.exports = function buildHeaders2(config, dameInstance = {}) {
      const optionHeaders = config.headers;
      const dameInstanceHeaders = dameInstance.headers;
      if (optionHeaders && dameInstanceHeaders)
        return { ...dameInstanceHeaders, ...optionHeaders };
      if (optionHeaders)
        return optionHeaders;
      if (dameInstanceHeaders)
        return dameInstanceHeaders;
      return {};
    };
  }
});

// utils/raceTimeout.js
var require_raceTimeout = __commonJS({
  "utils/raceTimeout.js"(exports2, module2) {
    module2.exports = function raceTimeout2(promise, options, dameInstance) {
      let timeout;
      if (dameInstance.timeout)
        timeout = dameInstance.timeout;
      if (options.timeout)
        timeout = options.timeout;
      if (timeout) {
        return Promise.race([
          new Promise((resolve) => {
            setTimeout(() => resolve({
              isError: true,
              code: 0,
              status: "Timed out",
              response: null
            }), timeout);
          }),
          promise
        ]);
      } else {
        return promise;
      }
      ;
    };
  }
});

// utils/checkIsError.js
var require_checkIsError = __commonJS({
  "utils/checkIsError.js"(exports2, module2) {
    module2.exports = function checkIsError(code) {
      if (!code)
        return true;
      return !(code >= 200 && code < 300);
    };
  }
});

// utils/requestWeb.js
var require_requestWeb = __commonJS({
  "utils/requestWeb.js"(exports2, module2) {
    module2.exports = function requestWeb({
      method,
      fullUrl,
      body,
      config,
      instance
    }) {
      if (!["GET", "POST", "PUT", "DELETE", "PATCH"].includes(method)) {
        return {
          isError: true,
          code: -999,
          status: "Error",
          response: null,
          error: `Method ${method} is not valid.`
        };
      }
      ;
      return new Promise(async (resolve) => {
        try {
          const _fetchOptions = {
            method,
            ...config
          };
          if (method !== "GET")
            _fetchOptions.body = body;
          let response = await window.fetch(fullUrl, _fetchOptions);
          let data = response;
          const contentType = response.headers.get("Content-Type").split("; ");
          const contentTypeLow = contentType[0].toLowerCase();
          try {
            if (contentTypeLow.startsWith("application/json")) {
              const json = await response.json();
              data = json;
            } else if (contentTypeLow.startsWith("text")) {
              data.toString();
            }
            ;
          } catch (err) {
          }
          ;
          const checkIsError = config.checkIsError || instance.checkIsError;
          const isError = checkIsError(response.status);
          resolve({
            isError,
            code: response.status,
            status: response.statusText,
            response: data
          });
        } catch (err) {
          resolve({
            isError: true,
            code: -1,
            status: "No response from server",
            response: null,
            error: err
          });
        }
        ;
      });
    };
  }
});

// utils/requestNode.js
var require_requestNode = __commonJS({
  "utils/requestNode.js"(exports2, module2) {
    module2.exports = function requestNode({
      method,
      fullUrl,
      body,
      config,
      instance
    }) {
      const https = require("https");
      const http = require("http");
      const url = require("url");
      if (!["GET", "POST", "PUT", "DELETE", "PATCH"].includes(method)) {
        return {
          isError: true,
          code: -999,
          status: "Error",
          response: null,
          error: `Method ${method} is not valid.`
        };
      }
      ;
      let protocol;
      let fullUrlLow = fullUrl.toLowerCase();
      if (fullUrlLow.startsWith("https://")) {
        protocol = https;
      } else if (fullUrlLow.startsWith("http://")) {
        protocol = http;
      } else {
        return {
          isError: true,
          code: -999,
          status: "Error",
          response: null,
          error: `Protocol not valid. URL: ${fullUrl}`
        };
      }
      ;
      const _requestOptions = {
        method,
        ...config
      };
      let totalRedirects = 0;
      const _request = (fullUrl2) => {
        if (totalRedirects >= 5)
          return {
            isError: true,
            code: 0,
            status: "Error",
            response: null,
            error: "Too many redirects"
          };
        return new Promise((resolve) => {
          try {
            const req = protocol.request(fullUrl2, _requestOptions, (res) => {
              let data = [];
              res.on("data", (chunk) => data.push(chunk));
              res.on("end", () => {
                data = Buffer.concat(data);
                const headers = res.headers;
                if (res.statusCode > 300 && res.statusCode < 400) {
                  if (url.parse(headers.location).hostname) {
                    totalRedirects++;
                    resolve(_request(headers.location));
                  } else {
                    const parsedUrl = url.parse(fullUrl2);
                    const newUrl = `${parsedUrl.protocol}//${parsedUrl.host}${headers.location}`;
                    totalRedirects++;
                    resolve(_request(newUrl));
                  }
                  ;
                }
                ;
                const contentType = headers && headers["content-type"];
                const arrContentType = contentType && contentType.split("; ");
                const contentTypeLow = arrContentType && arrContentType.length > 0 && arrContentType[0].toLowerCase();
                try {
                  if (contentTypeLow.startsWith("application/json")) {
                    const json = JSON.parse(data);
                    data = json;
                  } else if (contentTypeLow.startsWith("text")) {
                    data.toString();
                  }
                  ;
                } catch (e) {
                }
                ;
                const checkIsError = config.checkIsError || instance.checkIsError;
                const isError = checkIsError(res.statusCode);
                resolve({
                  isError,
                  code: res.statusCode,
                  status: res.statusMessage,
                  response: data
                });
              });
            });
            req.on("error", async (err) => {
              resolve({
                isError: true,
                code: -1,
                status: "No response from server",
                response: null,
                error: err
              });
            });
            if (body)
              req.write(body);
            req.end();
          } catch (err) {
            resolve({
              isError: true,
              code: -999,
              status: "Exception",
              response: null,
              error: err
            });
          }
          ;
        });
      };
      return _request(fullUrl);
    };
  }
});

// src/dame.js
var buildUrl = require_buildUrl();
var buildHeaders = require_buildHeaders();
var raceTimeout = require_raceTimeout();
var fncCheckIsError = require_checkIsError();
var postWrapper = (_arguments, method, dameInstance) => {
  let [url, body = {}, config = {}] = _arguments;
  if (body && typeof body === "object")
    body = JSON.stringify(body);
  const fullUrl = buildUrl(url, dameInstance);
  const headers = buildHeaders(config, dameInstance);
  const fncRequest = typeof window !== "undefined" ? require_requestWeb() : require_requestNode();
  config.headers = {
    "Content-Type": "application/json",
    "Content-Length": body.length,
    ...headers
  };
  let promise = fncRequest({
    method,
    fullUrl,
    body,
    config,
    instance: dameInstance
  });
  return raceTimeout(promise, config, dameInstance);
};
var Dame = class {
  constructor(constructorOptions = {}) {
    __publicField(this, "get", function(url, config = {}) {
      const fullUrl = buildUrl(url, this);
      const headers = buildHeaders(config, this);
      config.headers = headers;
      const fncRequest = typeof window !== "undefined" ? require_requestWeb() : require_requestNode();
      let promise = fncRequest({
        method: "GET",
        fullUrl,
        config,
        instance: this
      });
      return raceTimeout(promise, config, this);
    });
    __publicField(this, "post", function() {
      return postWrapper(arguments, "POST", this);
    });
    __publicField(this, "put", function() {
      return postWrapper(arguments, "PUT", this);
    });
    __publicField(this, "patch", function() {
      return postWrapper(arguments, "PATCH", this);
    });
    __publicField(this, "delete", function() {
      return postWrapper(arguments, "DELETE", this);
    });
    __publicField(this, "new", (config, instanceName) => {
      const instance = new Dame(config);
      if (instanceName) {
        if (!this.instances)
          this.instances = {};
        this.instances[instanceName] = instance;
      }
      ;
      return instance;
    });
    const {
      baseUrl,
      options = {},
      headers = {},
      checkIsError = fncCheckIsError,
      timeout
    } = constructorOptions;
    this.baseUrl = baseUrl;
    this.options = options;
    this.headers = headers;
    this.checkIsError = checkIsError;
    this.timeout = timeout;
  }
};
module.exports = new Dame();
